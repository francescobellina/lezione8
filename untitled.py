# -*- coding: utf-8 -*-
"""Untitled.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/francescobellina/lezione7/blob/main/Untitled.ipynb

#ESERCIZIO 1
##generazione di numeri pseudo-casuali distribuiti esponenzialmente
"""

#Si generi un campione di numeri pseudo-casuali distribuiti secondo una distribuzione di densità ESPONENZIALE con tempo caratteristico tau di 5 secondi e
#si visualizzi la distribuzione del campione ottenuto in un ISTOGRAMMA utilizzando il METODO della FUNZIONE INVERSA.
#Si scrivano tutte le funzioni deputate alla generazione di numeri casuali in una libreria, implementata in file separati rispetto al programma principale.

import random
import matplotlib.pyplot as plt
import numpy as np
from math import floor
from scipy.stats import expon


def inv_exp (y, lamb = 1) :

    return -1 * np.log (1-y) / lamb #INVERSA della primitiva della funzione expon


def exp(y,lamb = 1):

    return expon.pdf(y, loc=lamb, scale=1)

def main () :
    '''
    Funzione che implementa il programma principale
    '''


    tau  = float (0.1) #metterlo come input, deve essere un valore positivo
    lamb = 1./tau

    N    = int (10000) #metterlo come input
    seed = 10        #metterlo come input

    random.seed (seed)
    randlist1 = []


    for i in range (N):
        randlist1.append (inv_exp (random.random(), lamb))  #random.random è un numero pseudo casuale passato alla funzione inversa




    # plotting of the generated list of numbers in a histogram. SI ORA TRATTA SOLO DI PLOTTARE

    nBins = floor (len (randlist1) / 100.)        # number of bins of the hitogram
    bin_edges = np.linspace (0., 3., nBins + 1)  # edges o the histogram bins
    x=(np.linspace(0.,3.,100))
    # disegno della funzione
    fig, ax = plt.subplots ()
    ax.set_title ('Istogramma di numeri random  con andamento exp', size=10)
    ax.set_xlabel ('random value')
    ax.set_ylabel ('events in bin')
    ax.hist (randlist1,      # list of numbers
             bins = bin_edges,
             color = 'orange',
             density = True,
            )
    ax.plot(x, lamb*np.exp(x*(-lamb)), color = 'red')
    plt.savefig ('es_4.6.png')


# ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----


if __name__ == "__main__":
    main ()

"""#ESERCIZIO 2:
##generazione di numeri pseudo-casuali distribuiti Poissonianamente
"""

#Si utilizzi il risultato del primo esercizio per simulare uno pseudo-esperimento di conteggio con caratteristiche di Poisson:

#si scelga un tempo caratteristico t0 di un processo di decadimento radioattivo;

#si scelta un tempo di misura tM entro cui fare conteggi;

#in un CICLO , si simulino N pseudo-esperimenti di conteggio, in cui, per ciascuno di essi,
#si simuli una sequenza di eventi casuali con intertempo caratteristico dei fenomeni di Poisson,
#fino a che il tempo totale trascorso non sia maggiore del tempo di misura, contando il numero di eventi generati che cascano nell’intervallo;

#si riempia un istogramma con i conteggi simulati per ogni esperimento


import random
import matplotlib.pyplot as plt
import numpy as np
from math import floor, exp
from scipy.stats import expon


def inv_exp (y, lamb = 1) :

    return -1 * np.log (1-y) / lamb #INVERSA della primitiva della funzione expon



def main () :
    '''
    Funzione che implementa il programma principale
    '''



    tau  = float (5) #metterlo come input, deve essere un valore positivo
    lamb = 1./tau
    t_misura = float(60)  # tempo di misura


    seed = 10
    random.seed (seed)

    randlist1 = []
  # ciclo su tanti pseudo-esperimenti
    for i in range(1000):
       t_tot = inv_exp (random.random(), lamb)
       N_evt = 0
       while (t_tot < t_misura):
           ++N_evt
           t_tot += inv_exp (random.random(), lamb)
       randlist1.append(N_evt)
    #ciclo su tanti pseudo-esperimenti


    nBins = floor (len (randlist1) / 100.)        # number of bins of the hitogram
    bin_edges = np.linspace (0., 3., nBins + 1)  # edges o the histogram bins

    # disegno della funzione
    fig, ax = plt.subplots ()
    ax.set_title ('Istogramma di numeri random distribuiti poissoniamente', size=10)
    ax.set_xlabel ('random value')
    ax.set_ylabel ('events in bin')
    ax.hist (randlist1,      # list of numbers
             bins = bin_edges,
             color = 'orange',
             # normed = True,
            )

    plt.savefig ('es_4.6.png')

# ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----


if __name__ == "__main__":
    main ()

"""#ESERCIZIO 3

"""

#Si utilizzi il codice sorgente scritto nell’esercizio precedente per aggiungere alla libreria sviluppata per l’esercizio 1 una funzione che generi numeri casuali secondo la distribuzione di Poisson,
#avendo la media di eventi attesi come parametro in ingresso.
#Si riscriva l’esercizio precedente facendo uso di questa funzione, disegnando anche l’istogramma della densità di probabilità



"""#ESERCIZIO 4"""

#Use the result from the previous exercise to calculate the statistics of a Poisson distribution varying the mean, from 1 to 250 (how should you sample the interval?).
#Plot the obtained behavior of skewness and kurtosis as function of the Poisson mean.



#Si utilizzi il risultato del primo esercizio per simulare uno pseudo-esperimento di conteggio con caratteristiche di Poisson:

#si scelga un tempo caratteristico t0 di un processo di decadimento radioattivo;

#si scelta un tempo di misura tM entro cui fare conteggi;

#in un CICLO , si simulino N pseudo-esperimenti di conteggio, in cui, per ciascuno di essi,
#si simuli una sequenza di eventi casuali con intertempo caratteristico dei fenomeni di Poisson,
#fino a che il tempo totale trascorso non sia maggiore del tempo di misura, contando il numero di eventi generati che cascano nell’intervallo;

#si riempia un istogramma con i conteggi simulati per ogni esperimento


import random
import matplotlib.pyplot as plt
import numpy as np
from math import floor, exp
from scipy.stats import expon


def inv_exp (y, lamb = 1) :

    return -1 * np.log (1-y) / lamb #INVERSA della primitiva della funzione (pdf) expon



def exp(y,lamb = 1):

    return expon.pdf(y, loc=lamb, scale=1)

def main () :
    '''
    Funzione che implementa il programma principale
    '''

#To obtain pseudo-random events distributed according to a Poisson probability distribution, one can:
#generate events according to an exponential probability density distribution with a characteristic time t0 set to unity
#count how many events fall into a specific interval tau chosen with length lambda where lambda is the mean of events expeceted from the poissin distribution




    tau  = float (5) #metterlo come input, deve essere un valore positivo
    lamb = 1./tau
    t_misura = float(60)  # tempo di misura

    seed = 10
    random.seed (seed)
    N = 100
    t=0
    #PSEUDOCODICE: un ciclo con while(t<t_misura) al cui interno riempio una certa lista
    randlist1 = []
    while(t<t_misura):
       for i in range (N):
        randlist1.append(inv_exp (random.random(), lamb))
    randlist1.append(len(randlist1))
    t=t+1



    nBins = floor (len (randlist1) / 100.)        # number of bins of the hitogram
    bin_edges = np.linspace (0., 3., nBins + 1)  # edges o the histogram bins

    # disegno della funzione
    fig, ax = plt.subplots ()
    ax.set_title ('Istogramma di numeri random distribuiti poissoniamente', size=10)
    ax.set_xlabel ('random value')
    ax.set_ylabel ('events in bin')
    ax.hist (randlist1,    # list of numbers
             bins = bin_edges,
             color = 'orange',
             # normed = True,
            )

    plt.savefig ('es_4.6.png')

# ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----


if __name__ == "__main__":
    main ()

#Si generi un campione di numeri pseudo-casuali distribuiti secondo una distribuzione di densità ESPONENZIALE con tempo caratteristico tau di 5 secondi e
#si visualizzi la distribuzione del campione ottenuto in un ISTOGRAMMA utilizzando il METODO della FUNZIONE INVERSA.
#Si scrivano tutte le funzioni deputate alla generazione di numeri casuali in una libreria, implementata in file separati rispetto al programma principale.

import random
import matplotlib.pyplot as plt
import numpy as np
from math import floor
from scipy.stats import expon


def inv_exp (y, lamb = 1) :

    return -1 * np.log (1-y) / lamb #INVERSA della primitiva della funzione expon


def exp(y,lamb = 1):

    return expon.pdf(y, loc=lamb, scale=1)

def main () :
    '''
    Funzione che implementa il programma principale
    '''


    tau  = float (0.1) #metterlo come input, deve essere un valore positivo
    lamb = 1./tau
    t_misura = float(10)  # tempo di misura

    seed = 10
    random.seed (seed)
    N = 100
    t=0
    hpoint = []


    for i in range (N):
     N_ev = 0
     t_tot = inv_exp(random.random(), lamb)
     while(t_tot < t_misura):
      ++N_ev
      t_tot = t_tot + inv_exp(random.random(),lamb)
     hpoint.append(N_ev)



    # plotting of the generated list of numbers in a histogram. SI ORA TRATTA SOLO DI PLOTTARE

    nBins = floor (len (hpoint) / 100.)        # number of bins of the hitogram
    bin_edges = np.linspace (0., 3., nBins + 1)  # edges o the histogram bins
    x=(np.linspace(0.,3.,100))
    # disegno della funzione
    fig, ax = plt.subplots ()
    ax.set_title ('Istogramma di numeri random  con andamento exp', size=10)
    ax.set_xlabel ('random value')
    ax.set_ylabel ('events in bin')
    ax.hist (hpoint,      # list of numbers
             bins = bin_edges,
             color = 'orange',
             #density = True,
            )
    #ax.plot(x, lamb*np.exp(x*(-lamb)), color = 'red')
    plt.savefig ('es_4.6.png')


# ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----


if __name__ == "__main__":
    main ()
